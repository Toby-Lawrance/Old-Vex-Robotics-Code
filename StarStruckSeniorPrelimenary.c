#pragma config(Sensor, in1,    GyroLeft,       sensorGyro)
#pragma config(Sensor, in2,    ZAccel,         sensorAccelerometer)
#pragma config(Sensor, in3,    XAccel,         sensorAccelerometer)
#pragma config(Sensor, in4,    YAccel,         sensorAccelerometer)
#pragma config(Sensor, in8,    GyroRight,      sensorGyro)
#pragma config(Motor,  port1,           LeftBack,      tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           LeftFront,     tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           RightFront,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          RightBack,     tmotorVex393TurboSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

bool InRange(float Actual,float Desired,float Lenience) // tolerances
{
	if(Actual < (Desired + Lenience) && Actual > (Desired - Lenience))
	{return true;}
	else
	{return false;}
}
float AccelRatio =0;
int xBias;
int yBias;
float AX[3];
float AY[3];
float VX[3];
float VXSuvat = 0;
float VYSuvat = 0;
float VY[3];
long T[3];
float HighestXVelocity = 0;

int RightGyro;
int LeftGyro;
int Gyro;
//[Tunable]
const int Step = 1;


int Loop = 2;

task CalculateVelocity
{
	for(int i = 0; i<3; i++)
	{
		VX[i] = 0;
		VY[i] = 0;
	}
	T[2] = nSysTime/1000;
	T[1] = (nSysTime-1)/1000;
	T[0] = (nSysTime-2)/1000;

	long Time = nSysTime/1000;
	long TimeLast = Time;


	while(true)
	{
		RightGyro = SensorValue[GyroRight];
		LeftGyro = SensorValue[GyroLeft];

		Gyro = (LeftGyro+RightGyro)/2;

		T[Loop] = nSysTime/(long)1000;
		Time = nSysTime/1000;
		AX[Loop] = (SensorValue[XAccel]-xBias)/(float)AccelRatio;
		AY[Loop] = (SensorValue[YAccel]-yBias)/(float)AccelRatio;
		if((T[0]-T[1] == 0)||(T[0] - T[2] == 0))
		{
			VX[Loop] = 0;
		} else
		{
		VX[Loop] = -((AX[2]*(T[0]-T[1])*(3*T[0]-T[1]-2*T[2]))+AX[1]*(T[0]-T[2])*(3*T[0] -2*T[1]-T[2])-AX[0]*(T[1]-T[2])*(T[1]-T[2])*(T[1]-T[2]));
		VX[Loop] = VX[Loop]/(float)(6*(T[0]-T[1])*(T[0]-T[2]));
	}

	VXSuvat = VXSuvat + AX[Loop]*(Time-TimeLast);
	VYSuvat = VYSuvat + AY[Loop]*(Time-TimeLast);

	if (VX[Loop] > HighestXVelocity)
	{
		HighestXVelocity = VX[Loop];
	}

		TimeLast = Time;
		Loop = Loop - 1;
		if(Loop == -1)
		{
			Loop = 2;
		}
		wait1Msec(Step);

	}
}



/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////
int zYDif = 0;

void pre_auton()
{
	bStopTasksBetweenModes = true;



}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// .....................................................................................
	// Insert user code here.
	// .....................................................................................
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
int ClampValue(int Value, int Max, int Min)
{
	if(Value > Max)
	{
		return Max;
	} else if (Value < Min)
	{
		return Min;
	} else
	{
		return Value;
	}
}
	int LJoyX;
	int LJoyY;
	int RJoyX;
	int RJoyY;
float XValue;
float YValue;
float ZValue;
task CalcAcceleration
{
	while(true)
	{
		XValue = (SensorValue[XAccel] - xBias)/(float)AccelRatio;
		YValue = (SensorValue[YAccel] - yBias)/(float)AccelRatio;
		ZValue = (SensorValue[ZAccel])/(float)AccelRatio;
		wait1Msec(1);
	}
}


task usercontrol()
{
	xBias = SensorValue[XAccel];
	yBias = SensorValue[YAccel];
	zYDif = SensorValue[ZAccel] - yBias;
	AccelRatio = zYDif/(float)9.801;


	startTask(CalcAcceleration);
	SensorValue[GyroLeft] = 0;
	SensorValue[GyroRight] = 0;

	startTask(CalculateVelocity);

	// User control code here, inside the loop

	while (true)
	{
		LJoyX = vexRT[Ch4];
		LJoyY = vexRT[Ch3];
		RJoyX = vexRT[Ch1];
		RJoyY = vexRT[Ch2];


	}
}
